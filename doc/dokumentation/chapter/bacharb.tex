\iffalse
Die nächsten drei Abschnitte sollten hier nicht vorkommen. Wenn die gesagten Dinge von relevanz sind, sollten sie in einem vorherigen Kapitel genannt werden. 

Die Absätze würde ich aber für deine kommende Bachelorarbeit irgendwo abspeichern.

Jede Architektur hat eigene unterschiedliche Stärke und ist für bestimmtes Problem geeignet. Die klassische Zustandsmaschine-Architektur ist flexibel und gut organisiert. Sie beinhaltet gute Fehlerbehandlungstechniken, die Überprüfung auf Fehler bei jeder Iteration und die Meldung von Fehlern an eine Fehlerbehandlungsroutine, wenn das Programm endet. Das bedeutet, dass die klassische Zustandsmaschine es dem Entwickler ermöglicht, das Programm als Reaktion auf Benutzereingaben oder bei Auftreten eines Fehlers korrekt zu beenden. Leider kann die klassische Zustandsmaschine immer nur einen Zustandsübergang auf einmal angeben. Es muss alle Objekte der Benutzeroberfläche abfragen, um Benutzereingaben zu erkennen, und es wird kontinuierlich wiederholt, auch wenn es auf Benutzereingaben wartet \citep[Kapitel 31.1]{Bress_Effective_Labview_programming_2013}. Die ereignisgesteuerte Zustandsmaschine verwendet eine Event-Struktur, um Benutzereingaben zu erkennen. Die Event-Struktur ist viel einfacher zu bedienen als das Abfragen von Objekten der Benutzeroberfläche. Sie sind auch leicht skalierbar. Neue Ereignisfälle können hinzugefügt werden, ohne den Code in bestehenden Fällen zu stören. Der Ereignisfall hat auch den Vorteil, dass LabVIEW in den Ruhezustand versetzt wird, während der Ereignisfall auf die Eingabe wartet. Dies gibt der CPU die Möglichkeit, andere Aufgaben auszuführen, während die ereignisgesteuerte Zustandsmaschine auf Benutzereingaben wartet. Die ereignisgesteuerte Zustandsmaschinenarchitektur ist jedoch nicht sinnvoll, wenn die Zustandsmaschine keinen Wartezustand hat. Event-Strukturen ermöglichen es dem Entwickler auch, die Benutzeroberfläche zu sperren, während das Ereignis verarbeitet wird, was zu unerwartetem Verhalten führen kann \citep[Kapitel 31.2]{Bress_Effective_Labview_programming_2013}.

Darüber hinaus ermöglicht die \textit{Queue}-Zustandsmaschine dem Entwickler, Sequenzen und nicht nur einen einzelnen Zustand anzugeben. Die Zustandsübergänge werden dann nicht von den einzelnen Zuständen, sondern von der \textit{Queue} vorgegeben. \textit{Queues} verbessern auch die Lesbarkeit, da der Leser Listen von Zuständen sehen kann, die in ihren natürlichen Sequenzen gruppiert sind, anstatt von einem Zustand zum nächsten springen zu müssen, um die wahrscheinliche Reihenfolge der Zustandsausführung herauszufinden. \textit{Queues} können auch zur Kommunikation zwischen parallelen Schleifen verwendet werden, ohne eine Datenabhängigkeit zu erzeugen. Auf der anderen Seite werden \textit{Queues} nicht nach Wert, sondern nach Referenz übergeben. Es kann zu \textit{Race Conditions} führen, wenn \textit{Queue}-Operationen parallel durchgeführt werden \citep[Kapitel 31.3]{Bress_Effective_Labview_programming_2013}. Nun kommt es zur Producer-Consumer-Zustandsmaschine. Es ist eine parallele Architektur und führt mehrere Aufgaben gleichzeitig aus, ohne sich gegenseitig zu stören. Der Nachteil einer parallelen Architektur ist, dass sie komplexer ist als Single-Loop-Architekturen. Zwischen den Schleifen muss ein Nachrichtensystem eingerichtet werden, das keine Datenabhängigkeit zwischen den Schleifen erzeugt. Parallele Schleifen schaffen auch Möglichkeiten für die \textit{Race Conditions} \citep[Kapitel 31.6]{Bress_Effective_Labview_programming_2013}.

In dem neuen Programm ist es zu erwarten, dass mehrere Aufgaben gleichzeitig zu erledigen sind, weil beispielsweise drei Geräte kontrolliert werden müssen. Das heißt kommt dafür die Producer-Consumer-Architektur in Frage. Wie im vorherigen Abschnitt bereits erwähnt, arbeitet die Producer-Consumer-Architektur mit parallelen Schleifen. Dies kann potenziell zu einer Race Condition führen. Race Conditions fallen vor, wenn die Reihenfolge eines Codes das Ergebnis beeinflusst. Race Conditions sind ein ernstes Thema, weil das unerwartet und unberechenbar geschieht und falsches Ergebnis liefern kann \citep[Kapitel 28]{Bress_Effective_Labview_programming_2013}. Daher ist es empfehlenswert, eine \textit{Queue} in Producer-Consumer-Architektur zu verwenden, um Datenabhängigkeit zu bekommen. Eine weitere gute Lösung ist es, kritische Stelle an dem Code zu finden und zu schützen. Um diese zu gelingen, soll der Code in einem separaten nicht-ablaufinvarianten Teilprogramm (non-reentrant Sub-VI) platziert werden. Dieser Sub-VI kann nicht parallel mit sich selbst ausgeführt werden. Also nur eine Kopie der Sub-VI (ein Klon) kann zum bestimmten Zeitpunkt ausgeführt werden.

--- später auch ---
Weiterhin sind die \textit{Queue}- und Ereignis-Struktur innerhalb der Producer-Consumer-Architektur gut passend. Einerseits ist die \textit{Queue} da, um die Race Condition zu verhinden und andererseits ist die Event-Struktur da, um die Kommunikation zwischen den Schleifen zu haben. Außerdem kommen die Ereignisse meistens von dem Benutzer, das heißt ist User Event ein guter Wahl. Nicht zu vergessen muss diese User Event in \textit{Queue} einen Namen bekommen, damit ein User Event Element für die \textit{Queue} überall generiert werden kann. Das ist gut gebraucht, weil viele Programmen (sowohl VIs als auch Sub-VIs) zur gleichen Zeit laufen. Darüber hinaus ist es auch gut, die entscheidenen Sub-VI geklont werden, um die Wahrscheinlichkeit zu geringen, Race Conditions aufzutreten. Interessant ist ebenfalls die Herangehensweise, dass die FGV-Methode von dem Speichermechanismus getrennt werden sollen, um die Wartbarkeit des Codes zu verbessern. Letztlich ist zur Darstellung der Messdaten das 3D-Graph-Modul nötig. Eine gute Lösung ist eine CW3D-Graph, die eine ActiveX-Quelle ist und 3D Oberflächen mit Verwendung von X, Y, Z aufzeichnet. Allerdings ist der Stil des Graphen getrennt in einer CWX-Datei (ComponentWorks Saved Style) zu speichern.
\fi